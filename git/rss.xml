<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Pype's mental data lake - git posts</title><link>https://pype.dev/git-rss.xml</link><description>Pypeaday posts - git posts</description><atom:link href="https://pype.dev/git-rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>bitmoji.png</url><title>Pype's mental data lake - git posts</title><link>https://pype.dev/git-rss.xml</link></image><language>en</language><lastBuildDate>Sat, 25 Jun 2022 12:28:37 +0000</lastBuildDate><item><title>Git ammend to a commit</title><link>https://pype.dev/til/git-ammend-no-edit</link><description>After carefully staging only lines related to a specific change and comitting I suddenly realized I missed one... darn, what do I do? Old me would have soft res</description><content:encoded>&lt;p&gt;After carefully staging only lines related to a specific change and comitting I suddenly realized I missed one... darn, what do I do?&lt;/p&gt;&lt;p&gt;Old me would have soft reset my branch to the previous commit and redone all my careful staging... what a PIA...&lt;/p&gt;&lt;p&gt;New me (credit: ThePrimeagen)...&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# stage other changes I missed&lt;/span&gt;git commit --amend --no-edit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded><guid isPermaLink="false">https://pype.dev/til/git-ammend-no-edit</guid><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate></item><item><title>Mu</title><link>https://pype.dev/til/mu</link><description>If you work with a template for several projects then you might sometimes need to do the same action across all repos. mu status mu sh mu stash There mu As you </description><content:encoded>&lt;p&gt;If you work with a template for several projects then you might sometimes need to do the same action across all repos.A good example of this is updating a package in &lt;code&gt;requirements.txt&lt;/code&gt; in every project, or refactoring a common module.If you have several repos to do this across then it can be time consuming... enter &lt;code&gt;mu-repo&lt;/code&gt;&lt;/p&gt;&lt;h2 id="mu"&gt;Mu&lt;/h2&gt;&lt;p&gt;&lt;a href="https://fabioz.github.io/mu-repo/"&gt;mu-repo&lt;/a&gt; is an awesome cli tool for working with multiple git repositories at the same time. There are several things you can do:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;mu status&lt;/code&gt; will give you the &lt;code&gt;git status&lt;/code&gt; of every registered repo (see below)&lt;/li&gt;&lt;li&gt;&lt;code&gt;mu sh&lt;/code&gt; will let you execute system level commands in every repo&lt;/li&gt;&lt;li&gt;&lt;code&gt;mu stash&lt;/code&gt; will stash all changes across all registered repos&lt;/li&gt;&lt;li&gt;There's literally a ton more but these are some handy ones&lt;/li&gt;&lt;/ol&gt;&lt;h2 id="registration"&gt;Registration&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mu&lt;/code&gt; tracks its own &lt;code&gt;groups&lt;/code&gt;, and there is a default group when no particular one is active.It's as simple as &lt;code&gt;mu register proj1 prog2 ...&lt;/code&gt; to get repos registered&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;â¯ mu register proj1 proj2Repository: proj1 registeredRepository: proj2 registeredâ¯ mu status  proj1 : git status    On branch main    No commits yet    Untracked files:    &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to include &lt;span class="k"&gt;in&lt;/span&gt; what will be committed&lt;span class="o"&gt;)&lt;/span&gt;    requirements.txt    nothing added to commit but untracked files present &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git add&amp;quot;&lt;/span&gt; to track&lt;span class="o"&gt;)&lt;/span&gt;  proj2 : git status    On branch main    No commits yet    Changes to be committed:    &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git rm --cached &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;    new file:   requirements.txt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="working-with-mu"&gt;Working with mu&lt;/h2&gt;&lt;p&gt;As you can see above I have two projects each with a &lt;code&gt;requirements.txt&lt;/code&gt; added but not committed yet.Using &lt;code&gt;mu&lt;/code&gt; I can stage this change across both repos at once.&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;â¯ mu add requirements.txt  proj1 : git add requirements.txt  proj2 : git add requirements.txt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then as you might imagine, I can make the commit in each repo&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;â¯ mu commit -m &lt;span class="s2"&gt;&amp;quot;Add requirements.txts&amp;quot;&lt;/span&gt;  proj1 : git commit -m Add requirements.txts    &lt;span class="o"&gt;[&lt;/span&gt;main &lt;span class="o"&gt;(&lt;/span&gt;root-commit&lt;span class="o"&gt;)&lt;/span&gt; 18376d7&lt;span class="o"&gt;]&lt;/span&gt; Add requirements.txts    &lt;span class="m"&gt;1&lt;/span&gt; file changed, &lt;span class="m"&gt;1&lt;/span&gt; insertion&lt;span class="o"&gt;(&lt;/span&gt;+&lt;span class="o"&gt;)&lt;/span&gt;    create mode &lt;span class="m"&gt;100644&lt;/span&gt; requirements.txt  proj2 : git commit -m Add requirements.txts    &lt;span class="o"&gt;[&lt;/span&gt;main &lt;span class="o"&gt;(&lt;/span&gt;root-commit&lt;span class="o"&gt;)&lt;/span&gt; 18376d7&lt;span class="o"&gt;]&lt;/span&gt; Add requirements.txts    &lt;span class="m"&gt;1&lt;/span&gt; file changed, &lt;span class="m"&gt;1&lt;/span&gt; insertion&lt;span class="o"&gt;(&lt;/span&gt;+&lt;span class="o"&gt;)&lt;/span&gt;    create mode &lt;span class="m"&gt;100644&lt;/span&gt; requirements.txt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="mu-groups"&gt;mu groups&lt;/h2&gt;&lt;p&gt;The other thing I got a lot of use out of recently was &lt;code&gt;mu&lt;/code&gt;'s groups.At work I have about 40 repos cloned that are all based on the same kedro pipeline template.Some of these projects have been deprecated.I also have several more repos that are not kedro template - custom libraries or something.&lt;code&gt;group&lt;/code&gt; let me utilize &lt;code&gt;mu&lt;/code&gt; across different groups of repos.&lt;/p&gt;&lt;p&gt;Say &lt;code&gt;proj2&lt;/code&gt; is a deprecated project that I don't need to worry about making changes to anymore.I don't just have to unregister it, instead I can make a group called "active" and register &lt;code&gt;proj1&lt;/code&gt; in that group&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;â¯ mu group add active --empty~/personalâ¯ mu group add deprecated --empty~/personalâ¯ mu group  active* deprecated&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; tells me which group is active. The &lt;code&gt;--empty&lt;/code&gt; flag tells &lt;code&gt;mu&lt;/code&gt; to not add all registered repos to that group.If I don't want to use any groups then &lt;code&gt;mu group reset&lt;/code&gt; will go back to the default group with all registered repos.&lt;/p&gt;&lt;p&gt;With groups I can register only the repos that I want to be working across in their own group and not worry about affecting other repos with my batch changes!&lt;/p&gt;</content:encoded><guid isPermaLink="false">https://pype.dev/til/mu</guid><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate></item><item><title>Git-Bisect</title><link>https://pype.dev/til/git-bisect</link><description>I try to commit a lot, and I also try to write useful tests appropriate for the scope of work I Whether by laziness, ignorance, or accepted tech debt I don Befo</description><content:encoded>&lt;p&gt;I try to commit a lot, and I also try to write useful tests appropriate for the scope of work I'm focusing on, but sometimes I drop the ball...&lt;/p&gt;&lt;p&gt;Whether by laziness, ignorance, or accepted tech debt I don't always code perfectly and recently I was dozens of commits into a new feature before realizing I broke something along the way that none of my tests caught...&lt;/p&gt;&lt;p&gt;Before today I would've manually reviewed every commit to see if something obvious slipped by me (talk about a time suck ğŸ˜©)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;There must be a better way&lt;/strong&gt;&lt;/p&gt;&lt;h1 id="bisect"&gt;Bisect?&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt; is the magic sauce for this exact problem...&lt;/p&gt;&lt;p&gt;You essentially create a range of commits to consider and let &lt;code&gt;git bisect&lt;/code&gt; guide you through them in a manner akin to Newton's method for finding the root of a continuous function.&lt;/p&gt;&lt;h1 id="how-to-do-it"&gt;How to do it?&lt;/h1&gt;&lt;p&gt;Start with &lt;code&gt;git bisect start&lt;/code&gt; and then choose the first &lt;code&gt;good&lt;/code&gt; commit (ie. a commit you know the bug isn't present in)&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sandbox  îœ¥ bisect-post  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect startsandbox  îœ¥ bisect-post &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect good 655332bbisect-post  HEAD         main         ORIG_HEAD5b31e1e  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD&lt;span class="o"&gt;]&lt;/span&gt;    add successful print &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;52&lt;/span&gt; seconds ago&lt;span class="o"&gt;)&lt;/span&gt;308247b  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD^&lt;span class="o"&gt;]&lt;/span&gt;   init another loop &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;77&lt;/span&gt; seconds ago&lt;span class="o"&gt;)&lt;/span&gt;4555c59  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD^^&lt;span class="o"&gt;]&lt;/span&gt;  introduce bug &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;9cf6d55  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~3&lt;span class="o"&gt;]&lt;/span&gt;  add successful loop &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;bcb41c3  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~4&lt;span class="o"&gt;]&lt;/span&gt;  change x to &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;3c34aac  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~5&lt;span class="o"&gt;]&lt;/span&gt;  init x to &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;12e53bd  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~6&lt;span class="o"&gt;]&lt;/span&gt;  print cwd &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;655332b  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~7&lt;span class="o"&gt;]&lt;/span&gt;  add example.py &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;lt;- I want to start at this commit&lt;/span&gt;59e0048  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~8&lt;span class="o"&gt;]&lt;/span&gt;  gitignore &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;23&lt;/span&gt; hours ago&lt;span class="o"&gt;)&lt;/span&gt;fb9e1fb  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~9&lt;span class="o"&gt;]&lt;/span&gt;  add reqs &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;23&lt;/span&gt; hours ago&lt;span class="o"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sandbox  îœ¥ bisect-post &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect bad 5b31e1ebisect-post                                                ORIG_HEADHEAD                                                       refs/bisect/good-655332b6c384934c2c00c3d4aba3011ccc1e5b57main5b31e1e  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD&lt;span class="o"&gt;]&lt;/span&gt;    add successful print &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;lt;- I start here with the &amp;quot;bad&amp;quot; commit&lt;/span&gt;308247b  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD^&lt;span class="o"&gt;]&lt;/span&gt;   init another loop &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;4555c59  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD^^&lt;span class="o"&gt;]&lt;/span&gt;  introduce bug &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;9cf6d55  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~3&lt;span class="o"&gt;]&lt;/span&gt;  add successful loop &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;bcb41c3  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~4&lt;span class="o"&gt;]&lt;/span&gt;  change x to &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;3c34aac  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~5&lt;span class="o"&gt;]&lt;/span&gt;  init x to &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;12e53bd  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~6&lt;span class="o"&gt;]&lt;/span&gt;  print cwd &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;655332b  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~7&lt;span class="o"&gt;]&lt;/span&gt;  add example.py &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;14&lt;/span&gt; minutes ago&lt;span class="o"&gt;)&lt;/span&gt;59e0048  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~8&lt;span class="o"&gt;]&lt;/span&gt;  gitignore &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;23&lt;/span&gt; hours ago&lt;span class="o"&gt;)&lt;/span&gt;fb9e1fb  -- &lt;span class="o"&gt;[&lt;/span&gt;HEAD~9&lt;span class="o"&gt;]&lt;/span&gt;  add reqs &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;23&lt;/span&gt; hours ago&lt;span class="o"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After starting bisect with a "good" start commit and a "bad" ending commit we can let git to it's thing!&lt;/p&gt;&lt;p&gt;Git checksout a commit somewhere about halfway between the good and bad commit so you can see if your bug is there or not.&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sandbox  îœ¥ bisect-post &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect bad 5b31e1eBisecting: &lt;span class="m"&gt;3&lt;/span&gt; revisions left to &lt;span class="nb"&gt;test&lt;/span&gt; after this &lt;span class="o"&gt;(&lt;/span&gt;roughly &lt;span class="m"&gt;2&lt;/span&gt; steps&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;bcb41c3854e343eade85353683f2c1c4ddde4e04&lt;span class="o"&gt;]&lt;/span&gt; change x to &lt;span class="m"&gt;10&lt;/span&gt;sandbox  îœ¥ HEAD &lt;span class="o"&gt;(&lt;/span&gt;bcb41c38&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In my example here I have a python script with some loops and print statements - they aren't really relevant, I just wanted an easy to follow git history.&lt;/p&gt;&lt;p&gt;So I check to see if the bug is present or not either by running/writing tests or replicating the bug somehow.&lt;/p&gt;&lt;p&gt;In this session commit &lt;code&gt;bcb41c38&lt;/code&gt; is actually just fine, so I do &lt;code&gt;git bisect good&lt;/code&gt;&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sandbox  îœ¥ HEAD &lt;span class="o"&gt;(&lt;/span&gt;bcb41c38&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect goodBisecting: &lt;span class="m"&gt;1&lt;/span&gt; revision left to &lt;span class="nb"&gt;test&lt;/span&gt; after this &lt;span class="o"&gt;(&lt;/span&gt;roughly &lt;span class="m"&gt;1&lt;/span&gt; step&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;4555c5979268dff6c475365fdc5ce1d4a12bd820&lt;span class="o"&gt;]&lt;/span&gt; introduce bug&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And we see that git moves on to checkout another commit...&lt;/p&gt;&lt;p&gt;In this case the next commit is the one where I introduced a bug&lt;/p&gt;&lt;p&gt;&lt;code&gt;git bisect bad&lt;/code&gt; then gives me:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sandbox  îœ¥ HEAD &lt;span class="o"&gt;(&lt;/span&gt;4555c597&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect badBisecting: &lt;span class="m"&gt;0&lt;/span&gt; revisions left to &lt;span class="nb"&gt;test&lt;/span&gt; after this &lt;span class="o"&gt;(&lt;/span&gt;roughly &lt;span class="m"&gt;0&lt;/span&gt; steps&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;9cf6d55301560c51e2f55404d0d80b1f1e22a33d&lt;span class="o"&gt;]&lt;/span&gt; add successful loop&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;At &lt;code&gt;4555c597&lt;/code&gt; the script works as expected so one more &lt;code&gt;git bisect good&lt;/code&gt; yields...&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sandbox  îœ¥ HEAD &lt;span class="o"&gt;(&lt;/span&gt;9cf6d553&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;BISECTING&lt;span class="o"&gt;)&lt;/span&gt;  ïˆ› Ã—1 via îˆµ  v3.8.11&lt;span class="o"&gt;(&lt;/span&gt;sandbox&lt;span class="o"&gt;)&lt;/span&gt;  on îŒ½ &lt;span class="o"&gt;(&lt;/span&gt;us-east-1&lt;span class="o"&gt;)&lt;/span&gt;â¯ git bisect good4555c5979268dff6c475365fdc5ce1d4a12bd820 is the first bad commitcommit 4555c5979268dff6c475365fdc5ce1d4a12bd820Author: &lt;span class="c1"&gt;########################### &lt;/span&gt;Date:   Tue May &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="m"&gt;09&lt;/span&gt;:00:00 &lt;span class="m"&gt;2022&lt;/span&gt; -0500    introduce bug example.py &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; +- &lt;span class="m"&gt;1&lt;/span&gt; file changed, &lt;span class="m"&gt;1&lt;/span&gt; insertion&lt;span class="o"&gt;(&lt;/span&gt;+&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt; deletion&lt;span class="o"&gt;(&lt;/span&gt;-&lt;span class="o"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id="what-happened"&gt;What happened?&lt;/h1&gt;&lt;p&gt;Git sliced up a range of commits based on me saying of the next one was good or bad and localized the commit that introduced a bug into my workflow!&lt;/p&gt;&lt;p&gt;I didn't have to manually review commits, click through logs, etc... I just let git checkout relevant commits and I ran whatever was appropriate for reproducing the bug to learn when it was comitted!&lt;/p&gt;</content:encoded><guid isPermaLink="false">https://pype.dev/til/git-bisect</guid><pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate></item></channel></rss>